```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>.NET 8 Identity Toy App in F#</title>
</head>
<body>
  <h1>.NET 8 Identity Toy App (F# Minimal API)</h1>

  <h2>1. Project Setup</h2>
  <pre>
dotnet new webapi -lang F# -o IdentityToy -minimal -f net8.0
cd IdentityToy
dotnet add package Microsoft.AspNetCore.Identity.EntityFrameworkCore
dotnet add package Microsoft.EntityFrameworkCore.InMemory
dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer
  </pre>
  <p>Here we replace SQLite from Kostis Grontis’s article with <code>InMemory</code>, and reference needed Identity & JWT auth.</p>

  <h2>2. Define User & Context</h2>
  <pre><code lang="fsharp">namespace IdentityToy

open Microsoft.AspNetCore.Identity
open Microsoft.EntityFrameworkCore
open Microsoft.AspNetCore.Identity.EntityFrameworkCore

type AppUser() =
    inherit IdentityUser()

type AppDbContext(options: DbContextOptions<AppDbContext>) =
    inherit IdentityDbContext<AppUser>(options)

    // Extra fields table-level, you can add Salary etc. later as DbSet&lt;_&gt; to model table.
  </code></pre>
  <p>Identity needs a store user table using <code>IdentityDbContext&lt;AppUser&gt;</code> :contentReference[oaicite:0]{index=0}. You can later create your model table (e.g., Employees) adding <code>Salary, Manager, FirstNm, LastNm, DeptNm</code> as a regular EF Core entity.</p>

  <h2>3. Register Services & Identity Endpoints</h2>
  <pre><code lang="fsharp">open Microsoft.AspNetCore.Builder
open Microsoft.Extensions.DependencyInjection

let builder = WebApplication.CreateBuilder()

builder.Services.AddDbContext<AppDbContext>(fun opts ->
    opts.UseInMemoryDatabase("ToyDb") |> ignore)

builder.Services.AddAuthorization()
builder.Services
    .AddIdentityApiEndpoints&lt;AppUser&gt;()
    .AddEntityFrameworkStores&lt;AppDbContext&gt;()

builder.Services.AddAuthentication().AddJwtBearer(fun options ->
    // configure JWT options here (optional, identity returns opaque token by default)
    ())

let app = builder.Build()

app.UseAuthentication()
app.UseAuthorization()

app.MapIdentityApi&lt;AppUser&gt;() |> ignore

app.MapGet("/weatherforecast", fun () ->
    [| {| date = System.DateTime.UtcNow; tempC = 25; summary = "Sunny" |} |])
    .RequireAuthorization()
  </code></pre>
  <p>This mirrors the setup in Kostis and Andrew Lock’s posts. The AddIdentityApiEndpoints configures endpoints like <code>/register</code>, <code>/login</code>, etc. :contentReference[oaicite:1]{index=1}</p>

  <h2>4. Adding Custom Fields Table</h2>
  <pre><code lang="fsharp">type Employee =
    { Id: int
      FirstNm: string
      LastNm: string
      DeptNm: string
      Salary: decimal
      Manager: string }

type AppDbContext(options) =
    inherit IdentityDbContext<AppUser>(options)
    [<DefaultValue>]
    val mutable employees: DbSet&lt;Employee&gt;
    member this.Employees with get() = this.employees and set v = this.employees <- v
  </code></pre>
  <p>You need to <code>builder.Services.AddDbContext</code> above — that adds your extra data. Table-level and field-level logic you'll build in middleware later.</p>

  <h2>5. Testing Endpoints with Browser Console</h2>
  <p>Yes—you can call the endpoints via JavaScript in the browser. Example:</p>
  <pre><code>async function register() {
  const res = await fetch("/register", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ username:"u1", password:"P@ssw0rd!", email:"u1@example.com" })
  });
  console.log(await res.json());
}

async function login() {
  const res = await fetch("/login", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ username:"u1", password:"P@ssw0rd!" })
  });
  const data = await res.json();
  console.log(data);
  localStorage.setItem("token", data.access_token);
}

async function getForecast() {
  const token = localStorage.getItem("token");
  const res = await fetch("/weatherforecast", {
    headers: { "Authorization": `Bearer ${token}` }
  });
  console.log(await res.json());
}</code></pre>
  <p>Open devtools console, paste these functions to test manually.</p>

  <h2>6. Full Test Script</h2>
  <pre><code>// run in browser console or in Postman-like .http file
await register();
await login();
await getForecast();</code></pre>

  <h2>7. What Identity Requires from Backend</h2>
  <ul>
    <li>Table <code>AspNetUsers</code> with username, email, password-hash, security-stamp, etc.</li>
    <li>Email, Username, PasswordHash, NormalizedUserName, NormalizedEmail, etc.—default fields provided by IdentityUser :contentReference[oaicite:2]{index=2}.</li>
    <li>Entity <code>Employee</code> with added fields: Salary, Manager, FirstNm, LastNm, DeptNm as needed by you.</li>
  </ul>

  <h2>8. Next Steps</h2>
  <p>Once endpoints are functioning, you can:</p>
  <ol>
    <li>Add F# middleware to enforce table-level security on <code>Employees</code>.</li>
    <li>Implement field-level filtering, customizing EF Core or filtering in memory.</li>
    <li>Eventually, swap InMemory with SQL Server or another store.</li>
  </ol>

  <h2>Summary</h2>
  <p>We’ve translated Kostis Grontis’s C# sample into F#, using an in-memory DB, added your custom entity fields, and created JS test stubs for all Identity endpoints without Swagger.</p>
  <p>Next we can jump into middleware and role testing once this runs OK. Let me know when you’re ready to move forward!</p>
</body>
</html>
```
