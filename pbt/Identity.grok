I'll create an F# .NET application with Identity, using an in-memory database and including JavaScript for browser-based endpoint testing. The solution will include a custom DatabaseContext with additional fields and scripts to test all Identity endpoints.

```fsharp
module Program

open System
open Microsoft.AspNetCore.Builder
open Microsoft.AspNetCore.Identity
open Microsoft.EntityFrameworkCore
open Microsoft.Extensions.DependencyInjection
open Microsoft.Extensions.Hosting
open Microsoft.AspNetCore.Mvc
open Microsoft.AspNetCore.Authentication.JwtBearer
open Microsoft.IdentityModel.Tokens
open System.Text
open System.ComponentModel.DataAnnotations

// User model with custom fields
type ApplicationUser() =
    inherit IdentityUser()
    member val Salary = 0.0 with get, set
    member val Manager = "" with get, set
    member val FirstName = "" with get, set
    member val LastName = "" with get, set
    member val DepartmentName = "" with get, set

// In-memory database context
type ApplicationDbContext(options: DbContextOptions<ApplicationDbContext>) =
    inherit IdentityDbContext<ApplicationUser>(options)

// Configure in-memory database
let configureServices (services: IServiceCollection) =
    services.AddDbContext<ApplicationDbContext>(fun options ->
        options.UseInMemoryDatabase("IdentityDb") |> ignore)
        .AddIdentity<ApplicationUser, IdentityRole>(fun options ->
            options.Password.RequireDigit <- true
            options.Password.RequiredLength <- 6
            options.Password.RequireNonAlphanumeric <- false
            options.Password.RequireUppercase <- false
            options.Password.RequireLowercase <- false)
        .AddEntityFrameworkStores<ApplicationDbContext>()
        .AddDefaultTokenProviders() |> ignore

    let key = Encoding.ASCII.GetBytes("your-256-bit-secret-key-here-1234567890")
    services.AddAuthentication(fun options ->
        options.DefaultAuthenticateScheme <- JwtBearerDefaults.AuthenticationScheme
        options.DefaultChallengeScheme <- JwtBearerDefaults.AuthenticationScheme)
        .AddJwtBearer(fun options ->
            options.TokenValidationParameters <- TokenValidationParameters(
                ValidateIssuer = false,
                ValidateAudience = false,
                ValidateLifetime = true,
                ValidateIssuerSigningKey = true,
                IssuerSigningKey = SymmetricSecurityKey(key))) |> ignore

// User registration DTO
type RegisterModel = {
    [<Required>]
    Email: string
    [<Required>]
    Password: string
    FirstName: string
    LastName: string
    DepartmentName: string
    Salary: float
    Manager: string
}

// User login DTO
type LoginModel = {
    [<Required>]
    Email: string
    [<Required>]
    Password: string
}

// Password reset DTO
type ResetPasswordModel = {
    Email: string
    Token: string
    NewPassword: string
}

// API Controller
type AccountController(userManager: UserManager<ApplicationUser>, signInManager: SignInManager<ApplicationUser>) =
    inherit ControllerBase()

    [<HttpPost("/api/account/register")>]
    member _.Register(model: RegisterModel) = async {
        let user = ApplicationUser(
            UserName = model.Email,
            Email = model.Email,
            FirstName = model.FirstName,
            LastName = model.LastName,
            DepartmentName = model.DepartmentName,
            Salary = model.Salary,
            Manager = model.Manager
        )
        let! result = userManager.CreateAsync(user, model.Password) |> Async.AwaitTask
        if result.Succeeded then
            return _.Ok("User registered successfully")
        else
            return _.BadRequest(result.Errors)
    }

    [<HttpPost("/api/account/login")>]
    member _.Login(model: LoginModel) = async {
        let! result = signInManager.PasswordSignInAsync(model.Email, model.Password, false, false) |> Async.AwaitTask
        if result.Succeeded then
            let user = userManager.FindByEmailAsync(model.Email) |> Async.AwaitTask |> Async.RunSynchronously
            let claims = [|
                System.Security.Claims.Claim(System.Security.Claims.ClaimTypes.Name, user.UserName)
            |]
            let key = SymmetricSecurityKey(Encoding.UTF8.GetBytes("your-256-bit-secret-key-here-1234567890"))
            let creds = SigningCredentials(key, SecurityAlgorithms.HmacSha256)
            let token = JwtSecurityToken(
                issuer = null,
                audience = null,
                claims = claims,
                expires = Nullable(DateTime.Now.AddHours(1.0)),
                signingCredentials = creds
            )
            return _.Ok(JwtSecurityTokenHandler().WriteToken(token))
        else
            return _.Unauthorized("Invalid login attempt")
    }

    [<HttpPost("/api/account/reset-password")>]
    member _.ResetPassword(model: ResetPasswordModel) = async {
        let user = userManager.FindByEmailAsync(model.Email) |> Async.AwaitTask |> Async.RunSynchronously
        if user = null then
            return _.BadRequest("User not found")
        let! result = userManager.ResetPasswordAsync(user, model.Token, model.NewPassword) |> Async.AwaitTask
        if result.Succeeded then
            return _.Ok("Password reset successfully")
        else
            return _.BadRequest(result.Errors)
    }

    [<HttpPost("/api/account/forgot-password")>]
    member _.ForgotPassword(model: {| Email: string |}) = async {
        let user = userManager.FindByEmailAsync(model.Email) |> Async.AwaitTask |> Async.RunSynchronously
        if user = null then
            return _.Ok() // Don't reveal user doesn't exist
        let! token = userManager.GeneratePasswordResetTokenAsync(user) |> Async.AwaitTask
        return _.Ok({| Token = token |})
    }

// Main application
[<EntryPoint>]
let main args =
    let builder = WebApplication.CreateBuilder(args)
    configureServices builder.Services
    builder.Services.AddControllers() |> ignore
    let app = builder.Build()
    
    app.UseAuthentication() |> ignore
    app.UseAuthorization() |> ignore
    app.MapControllers() |> ignore
    
    app.Run()
    0
```

```javascript
async function testIdentityEndpoints() {
    const baseUrl = 'https://localhost:5001/api/account';
    
    // Test Registration
    async function testRegister() {
        const response = await fetch(`${baseUrl}/register`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                email: 'test@example.com',
                password: 'Test123',
                firstName: 'John',
                lastName: 'Doe',
                departmentName: 'IT',
                salary: 50000,
                manager: 'Jane Smith'
            })
        });
        console.log('Register:', await response.json());
    }

    // Test Login
    async function testLogin() {
        const response = await fetch(`${baseUrl}/login`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                email: 'test@example.com',
                password: 'Test123'
            })
        });
        const result = await response.json();
        console.log('Login:', result);
        return result; // Returns JWT token
    }

    // Test Forgot Password
    async function testForgotPassword() {
        const response = await fetch(`${baseUrl}/forgot-password`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ email: 'test@example.com' })
        });
        const result = await response.json();
        console.log('Forgot Password:', result);
        return result.token;
    }

    // Test Reset Password
    async function testResetPassword(token) {
        const response = await fetch(`${baseUrl}/reset-password`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                email: 'test@example.com',
                token: token,
                newPassword: 'NewPass123'
            })
        });
        console.log('Reset Password:', await response.json());
    }

    try {
        await testRegister();
        const token = await testLogin();
        const resetToken = await testForgotPassword();
        await testResetPassword(resetToken);
    } catch (error) {
        console.error('Test failed:', error);
    }
}

// Run tests from browser console
// testIdentityEndpoints();
```

This solution includes:

1. An F# ASP.NET Core application with Identity using an in-memory database
2. A custom `ApplicationUser` class with additional fields (Salary, Manager, FirstName, LastName, DepartmentName)
3. API endpoints for registration, login, forgot password, and password reset
4. A JavaScript file for testing endpoints via browser console
5. JWT-based authentication

To use:
1. Create a new F# ASP.NET Core project
2. Replace Program.fs with the provided code
3. Save test_endpoints.js locally
4. Run the application
5. Open browser console, load test_endpoints.js, and run `testIdentityEndpoints()`

The in-memory database replaces SQLite, storing data in memory during runtime. The JavaScript test script covers all endpoints. You can extend this later with custom middleware for role-based authorization. Make sure to update the secret key in the JWT configuration.

For reference, this is adapted from Kostis Grontis's article on .NET 8 Identity endpoints.[](https://kgrontis.github.io/posts/Exploring-Identity-Endpoints-in-.NET-8/)
